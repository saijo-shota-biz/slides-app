// @ts-nocheck
// Code generated by sqlc-gen-ts-d1. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
//   sqlc-gen-ts-d1 v0.0.0-a@a3d312f03e80d6530ea7be50c1b39cf2e34cfa846d91751973ed078cb2cddecc

import { D1Database, D1PreparedStatement, D1Result } from "@cloudflare/workers-types/experimental"

type Query<T> = {
  then(onFulfilled?: (value: T) => void, onRejected?: (reason?: any) => void): void;
  batch(): D1PreparedStatement;
}
const getUserQuery = `-- name: GetUser :one
SELECT id, created_at, updated_at, email, username
FROM users
WHERE id = ?1`;

export type GetUserParams = {
  id: string;
};

export type GetUserRow = {
  id: string;
  createdAt: string | null;
  updatedAt: string | null;
  email: string;
  username: string;
};

type RawGetUserRow = {
  id: string;
  created_at: string | null;
  updated_at: string | null;
  email: string;
  username: string;
};

export function getUser(
  d1: D1Database,
  args: GetUserParams
): Query<GetUserRow | null> {
  const ps = d1
    .prepare(getUserQuery)
    .bind(args.id);
  return {
    then(onFulfilled?: (value: GetUserRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawGetUserRow | null>()
        .then((raw: RawGetUserRow | null) => raw ? {
          id: raw.id,
          createdAt: raw.created_at,
          updatedAt: raw.updated_at,
          email: raw.email,
          username: raw.username,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getUserByEmailQuery = `-- name: GetUserByEmail :one
SELECT id, created_at, updated_at, email, username
FROM users
WHERE email = ?1`;

export type GetUserByEmailParams = {
  email: string;
};

export type GetUserByEmailRow = {
  id: string;
  createdAt: string | null;
  updatedAt: string | null;
  email: string;
  username: string;
};

type RawGetUserByEmailRow = {
  id: string;
  created_at: string | null;
  updated_at: string | null;
  email: string;
  username: string;
};

export function getUserByEmail(
  d1: D1Database,
  args: GetUserByEmailParams
): Query<GetUserByEmailRow | null> {
  const ps = d1
    .prepare(getUserByEmailQuery)
    .bind(args.email);
  return {
    then(onFulfilled?: (value: GetUserByEmailRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawGetUserByEmailRow | null>()
        .then((raw: RawGetUserByEmailRow | null) => raw ? {
          id: raw.id,
          createdAt: raw.created_at,
          updatedAt: raw.updated_at,
          email: raw.email,
          username: raw.username,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const listUsersQuery = `-- name: ListUsers :many
SELECT id, created_at, updated_at, email, username
FROM users`;

export type ListUsersRow = {
  id: string;
  createdAt: string | null;
  updatedAt: string | null;
  email: string;
  username: string;
};

type RawListUsersRow = {
  id: string;
  created_at: string | null;
  updated_at: string | null;
  email: string;
  username: string;
};

export function listUsers(
  d1: D1Database
): Query<D1Result<ListUsersRow>> {
  const ps = d1
    .prepare(listUsersQuery);
  return {
    then(onFulfilled?: (value: D1Result<ListUsersRow>) => void, onRejected?: (reason?: any) => void) {
      ps.all<RawListUsersRow>()
        .then((r: D1Result<RawListUsersRow>) => { return {
          ...r,
          results: r.results.map((raw: RawListUsersRow) => { return {
            id: raw.id,
            createdAt: raw.created_at,
            updatedAt: raw.updated_at,
            email: raw.email,
            username: raw.username,
          }}),
        }})
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const createUserQuery = `-- name: CreateUser :one
INSERT INTO users (id, email, username)
VALUES (?1, ?2, ?3)
RETURNING id, created_at, updated_at, email, username`;

export type CreateUserParams = {
  id: string;
  email: string;
  username: string;
};

export type CreateUserRow = {
  id: string;
  createdAt: string | null;
  updatedAt: string | null;
  email: string;
  username: string;
};

type RawCreateUserRow = {
  id: string;
  created_at: string | null;
  updated_at: string | null;
  email: string;
  username: string;
};

export function createUser(
  d1: D1Database,
  args: CreateUserParams
): Query<CreateUserRow | null> {
  const ps = d1
    .prepare(createUserQuery)
    .bind(args.id, args.email, args.username);
  return {
    then(onFulfilled?: (value: CreateUserRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawCreateUserRow | null>()
        .then((raw: RawCreateUserRow | null) => raw ? {
          id: raw.id,
          createdAt: raw.created_at,
          updatedAt: raw.updated_at,
          email: raw.email,
          username: raw.username,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const updateUserUsernameQuery = `-- name: UpdateUserUsername :one
UPDATE users
SET username = ?1
WHERE id = ?2
RETURNING id, created_at, updated_at, email, username`;

export type UpdateUserUsernameParams = {
  username: string;
  id: string;
};

export type UpdateUserUsernameRow = {
  id: string;
  createdAt: string | null;
  updatedAt: string | null;
  email: string;
  username: string;
};

type RawUpdateUserUsernameRow = {
  id: string;
  created_at: string | null;
  updated_at: string | null;
  email: string;
  username: string;
};

export function updateUserUsername(
  d1: D1Database,
  args: UpdateUserUsernameParams
): Query<UpdateUserUsernameRow | null> {
  const ps = d1
    .prepare(updateUserUsernameQuery)
    .bind(args.username, args.id);
  return {
    then(onFulfilled?: (value: UpdateUserUsernameRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawUpdateUserUsernameRow | null>()
        .then((raw: RawUpdateUserUsernameRow | null) => raw ? {
          id: raw.id,
          createdAt: raw.created_at,
          updatedAt: raw.updated_at,
          email: raw.email,
          username: raw.username,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const deleteUserQuery = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = ?1`;

export type DeleteUserParams = {
  id: string;
};

export function deleteUser(
  d1: D1Database,
  args: DeleteUserParams
): Query<D1Result> {
  const ps = d1
    .prepare(deleteUserQuery)
    .bind(args.id);
  return {
    then(onFulfilled?: (value: D1Result) => void, onRejected?: (reason?: any) => void) {
      ps.run()
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

